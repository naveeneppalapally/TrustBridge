rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {
    function isAuthed() {
      return request.auth != null;
    }

    function isParent(parentId) {
      return isAuthed() && request.auth.uid == parentId;
    }

    function isSixDigitCode(value) {
      return value is string && value.matches('^[0-9]{6}$');
    }

    function isChildOwner(childId) {
      return isAuthed() &&
        exists(/databases/$(database)/documents/children/$(childId)) &&
        get(/databases/$(database)/documents/children/$(childId)).data.parentId == request.auth.uid;
    }

    function hasOnlyKeys(data, allowedKeys) {
      return data.keys().hasOnly(allowedKeys);
    }

    function isRequiredString(data, field, maxLen) {
      return field in data &&
        data[field] is string &&
        data[field].size() > 0 &&
        data[field].size() <= maxLen;
    }

    function isOptionalString(data, field, maxLen) {
      return !(field in data) ||
        data[field] == null ||
        (data[field] is string && data[field].size() > 0 && data[field].size() <= maxLen);
    }

    function isOptionalInt(data, field, min, max) {
      return !(field in data) ||
        data[field] == null ||
        (data[field] is int && data[field] >= min && data[field] <= max);
    }

    function isRequiredBool(data, field) {
      return field in data && data[field] is bool;
    }

    function isRequiredTimestamp(data, field) {
      return field in data && data[field] is timestamp;
    }

    function isOptionalTimestamp(data, field) {
      return !(field in data) || data[field] == null || data[field] is timestamp;
    }

    function isAllowedAgeBand(data, field) {
      return field in data &&
        data[field] is string &&
        data[field] in ['6-9', '10-13', '14-17'];
    }

    function hasRequiredAlertLocks(data) {
      return !('alertPreferences' in data) ||
        (
          data.alertPreferences is map &&
          (
            !('vpnDisabled' in data.alertPreferences) ||
            data.alertPreferences.vpnDisabled == true
          ) &&
          (
            !('uninstallAttempt' in data.alertPreferences) ||
            data.alertPreferences.uninstallAttempt == true
          ) &&
          (
            !('deviceOffline24h' in data.alertPreferences) ||
            data.alertPreferences.deviceOffline24h == true
          )
        );
    }

    // Parent profile document.
    match /parents/{parentId} {
      allow read: if isParent(parentId);

      allow create: if isParent(parentId) &&
        isRequiredString(request.resource.data, 'parentId', 128) &&
        request.resource.data.parentId == parentId &&
        (!('phone' in request.resource.data) ||
          request.resource.data.phone == null ||
          (request.resource.data.phone is string && request.resource.data.phone.size() <= 20)) &&
        (!('preferences' in request.resource.data) || request.resource.data.preferences is map) &&
        (!('subscription' in request.resource.data) || request.resource.data.subscription is map) &&
        isOptionalString(request.resource.data, 'fcmToken', 1024) &&
        isOptionalTimestamp(request.resource.data, 'createdAt') &&
        isOptionalTimestamp(request.resource.data, 'updatedAt') &&
        isOptionalTimestamp(request.resource.data, 'fcmTokenUpdatedAt') &&
        isOptionalTimestamp(request.resource.data, 'onboardingCompletedAt') &&
        hasRequiredAlertLocks(request.resource.data);

      allow update: if isParent(parentId) &&
        isRequiredString(request.resource.data, 'parentId', 128) &&
        request.resource.data.parentId == resource.data.parentId &&
        request.resource.data.parentId == parentId &&
        hasRequiredAlertLocks(request.resource.data);

      allow delete: if false;

      // Access requests live under each parent.
      match /access_requests/{requestId} {
        allow read: if isParent(parentId);

        allow create: if isParent(parentId) &&
          hasOnlyKeys(
            request.resource.data,
            [
              'childId',
              'parentId',
              'childNickname',
              'appOrSite',
              'durationMinutes',
              'durationLabel',
              'reason',
              'status',
              'parentReply',
              'requestedAt',
              'respondedAt',
              'expiresAt'
            ]
          ) &&
          isRequiredString(request.resource.data, 'childId', 128) &&
          isRequiredString(request.resource.data, 'parentId', 128) &&
          request.resource.data.parentId == parentId &&
          isRequiredString(request.resource.data, 'childNickname', 30) &&
          isRequiredString(request.resource.data, 'appOrSite', 100) &&
          isRequiredString(request.resource.data, 'durationLabel', 40) &&
          isOptionalInt(request.resource.data, 'durationMinutes', 1, 1440) &&
          isOptionalString(request.resource.data, 'reason', 200) &&
          request.resource.data.status == 'pending' &&
          isRequiredTimestamp(request.resource.data, 'requestedAt') &&
          (!('parentReply' in request.resource.data) || request.resource.data.parentReply == null) &&
          (!('respondedAt' in request.resource.data) || request.resource.data.respondedAt == null) &&
          (!('expiresAt' in request.resource.data) || request.resource.data.expiresAt == null);

        allow update: if isParent(parentId) &&
          (
            (
              resource.data.status == 'pending' &&
              request.resource.data.diff(resource.data).affectedKeys().hasOnly(
                ['status', 'parentReply', 'respondedAt', 'expiresAt']
              ) &&
              request.resource.data.status in ['approved', 'denied'] &&
              isOptionalString(request.resource.data, 'parentReply', 200) &&
              isRequiredTimestamp(request.resource.data, 'respondedAt') &&
              isOptionalTimestamp(request.resource.data, 'expiresAt')
            ) ||
            (
              resource.data.status == 'approved' &&
              request.resource.data.diff(resource.data).affectedKeys().hasOnly(
                ['status', 'parentReply', 'expiresAt', 'expiredAt', 'updatedAt']
              ) &&
              request.resource.data.status == 'expired' &&
              isOptionalString(request.resource.data, 'parentReply', 200) &&
              isRequiredTimestamp(request.resource.data, 'expiresAt') &&
              isRequiredTimestamp(request.resource.data, 'expiredAt') &&
              isRequiredTimestamp(request.resource.data, 'updatedAt')
            )
          );

        allow delete: if isParent(parentId);
      }
    }

    // Child profiles (top-level collection in v1 schema).
    match /children/{childId} {
      allow read: if isAuthed() && resource.data.parentId == request.auth.uid;

      allow create: if isAuthed() &&
        hasOnlyKeys(
          request.resource.data,
          [
            'nickname',
            'ageBand',
            'deviceIds',
            'policy',
            'createdAt',
            'updatedAt',
            'parentId',
            'pausedUntil',
            'nextDnsProfileId',
            'deviceMetadata',
            'nextDnsControls'
          ]
        ) &&
        isRequiredString(request.resource.data, 'nickname', 30) &&
        isAllowedAgeBand(request.resource.data, 'ageBand') &&
        request.resource.data.deviceIds is list &&
        request.resource.data.policy is map &&
        isRequiredTimestamp(request.resource.data, 'createdAt') &&
        isRequiredTimestamp(request.resource.data, 'updatedAt') &&
        isRequiredString(request.resource.data, 'parentId', 128) &&
        request.resource.data.parentId == request.auth.uid &&
        isOptionalTimestamp(request.resource.data, 'pausedUntil') &&
        isOptionalString(request.resource.data, 'nextDnsProfileId', 32) &&
        (!('deviceMetadata' in request.resource.data) ||
          request.resource.data.deviceMetadata is map) &&
        (!('nextDnsControls' in request.resource.data) ||
          request.resource.data.nextDnsControls is map);

      allow update: if isAuthed() &&
        resource.data.parentId == request.auth.uid &&
        request.resource.data.parentId == resource.data.parentId &&
        request.resource.data.diff(resource.data).affectedKeys().hasOnly(
          [
            'nickname',
            'ageBand',
            'deviceIds',
            'policy',
            'pausedUntil',
            'updatedAt',
            'nextDnsProfileId',
            'deviceMetadata',
            'nextDnsControls'
          ]
        ) &&
        isRequiredString(request.resource.data, 'nickname', 30) &&
        isAllowedAgeBand(request.resource.data, 'ageBand') &&
        request.resource.data.deviceIds is list &&
        request.resource.data.policy is map &&
        isRequiredTimestamp(request.resource.data, 'createdAt') &&
        isRequiredTimestamp(request.resource.data, 'updatedAt') &&
        isOptionalTimestamp(request.resource.data, 'pausedUntil') &&
        isOptionalString(request.resource.data, 'nextDnsProfileId', 32) &&
        (!('deviceMetadata' in request.resource.data) ||
          request.resource.data.deviceMetadata is map) &&
        (!('nextDnsControls' in request.resource.data) ||
          request.resource.data.nextDnsControls is map);

      allow delete: if isAuthed() && resource.data.parentId == request.auth.uid;

      // Child device metadata records used for pairing and per-device push tokens.
      match /devices/{deviceId} {
        allow read: if isChildOwner(childId);

        allow create, update: if isChildOwner(childId) &&
          isRequiredString(request.resource.data, 'parentId', 128) &&
          request.resource.data.parentId == request.auth.uid &&
          isOptionalString(request.resource.data, 'model', 120) &&
          isOptionalString(request.resource.data, 'osVersion', 120) &&
          isOptionalString(request.resource.data, 'fcmToken', 2048) &&
          isOptionalTimestamp(request.resource.data, 'pairedAt');

        allow delete: if false;
      }
    }

    // Parent-generated setup codes used to pair child devices.
    match /pairing_codes/{code} {
      allow read: if isAuthed();

      allow create: if isAuthed() &&
        isSixDigitCode(code) &&
        hasOnlyKeys(
          request.resource.data,
          ['code', 'childId', 'parentId', 'createdAt', 'expiresAt', 'used']
        ) &&
        request.resource.data.code == code &&
        isRequiredString(request.resource.data, 'childId', 128) &&
        isRequiredString(request.resource.data, 'parentId', 128) &&
        request.resource.data.parentId == request.auth.uid &&
        isRequiredTimestamp(request.resource.data, 'createdAt') &&
        isRequiredTimestamp(request.resource.data, 'expiresAt') &&
        isRequiredBool(request.resource.data, 'used') &&
        request.resource.data.used == false;

      allow update: if isAuthed() &&
        request.resource.data.diff(resource.data).affectedKeys().hasOnly(
          ['used', 'usedAt', 'usedByDeviceId']
        ) &&
        resource.data.used == false &&
        isRequiredBool(request.resource.data, 'used') &&
        request.resource.data.used == true &&
        isOptionalTimestamp(request.resource.data, 'usedAt') &&
        isOptionalString(request.resource.data, 'usedByDeviceId', 128);

      allow delete: if false;
    }

    // Queue used by Cloud Functions (client can write, cannot read).
    match /notification_queue/{docId} {
      allow read: if false;

      allow create: if isAuthed() &&
        hasOnlyKeys(
          request.resource.data,
          ['parentId', 'title', 'body', 'route', 'processed', 'sentAt']
        ) &&
        isRequiredString(request.resource.data, 'parentId', 128) &&
        request.resource.data.parentId == request.auth.uid &&
        isRequiredString(request.resource.data, 'title', 100) &&
        isRequiredString(request.resource.data, 'body', 300) &&
        isRequiredString(request.resource.data, 'route', 100) &&
        isRequiredBool(request.resource.data, 'processed') &&
        request.resource.data.processed == false &&
        isRequiredTimestamp(request.resource.data, 'sentAt');

      allow update, delete: if false;
    }

    // Parent-submitted support tickets.
    match /supportTickets/{ticketId} {
      allow create: if isAuthed() &&
        hasOnlyKeys(
          request.resource.data,
          ['parentId', 'subject', 'message', 'childId', 'status', 'createdAt', 'updatedAt']
        ) &&
        isRequiredString(request.resource.data, 'parentId', 128) &&
        request.resource.data.parentId == request.auth.uid &&
        isRequiredString(request.resource.data, 'subject', 120) &&
        isRequiredString(request.resource.data, 'message', 2000) &&
        isOptionalString(request.resource.data, 'childId', 128) &&
        request.resource.data.status == 'open' &&
        isRequiredTimestamp(request.resource.data, 'createdAt') &&
        isRequiredTimestamp(request.resource.data, 'updatedAt');

      allow read: if isAuthed() && resource.data.parentId == request.auth.uid;
      allow update, delete: if false;
    }

    // Deny every non-whitelisted path.
    match /{document=**} {
      allow read, write: if false;
    }
  }
}
