rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {
    function isAuthed() {
      return request.auth != null;
    }

    function isParent(parentId) {
      return isAuthed() && request.auth.uid == parentId;
    }

    function isSixDigitCode(value) {
      return value is string && value.matches('^[0-9]{6}$');
    }

    function isChildParent(childId) {
      return isAuthed() &&
        exists(/databases/$(database)/documents/children/$(childId)) &&
        get(/databases/$(database)/documents/children/$(childId)).data.parentId == request.auth.uid;
    }

    function isChildDevice(childId) {
      return isChildParent(childId) || (
        isAuthed() &&
        exists(/databases/$(database)/documents/children/$(childId)/devices/$(request.auth.uid))
      );
    }

    function childParentMatches(childId, parentId) {
      return childId is string &&
        parentId is string &&
        exists(/databases/$(database)/documents/children/$(childId)) &&
        get(/databases/$(database)/documents/children/$(childId)).data.parentId == parentId;
    }

    function isRegisteredChildDevice(childId, deviceId) {
      return childId is string &&
        deviceId is string &&
        exists(/databases/$(database)/documents/children/$(childId)/devices/$(deviceId));
    }

    function parentOwnsRootDevice(deviceId) {
      return isAuthed() &&
        exists(/databases/$(database)/documents/devices/$(deviceId)) &&
        get(/databases/$(database)/documents/devices/$(deviceId)).data.parentId == request.auth.uid;
    }

    function hasOnlyKeys(data, allowedKeys) {
      return data.keys().hasOnly(allowedKeys);
    }

    function isRequiredString(data, field, maxLen) {
      return field in data &&
        data[field] is string &&
        data[field].size() > 0 &&
        data[field].size() <= maxLen;
    }

    function isOptionalString(data, field, maxLen) {
      return !(field in data) ||
        data[field] == null ||
        (data[field] is string && data[field].size() > 0 && data[field].size() <= maxLen);
    }

    function isOptionalInt(data, field, min, max) {
      return !(field in data) ||
        data[field] == null ||
        (data[field] is int && data[field] >= min && data[field] <= max);
    }

    function isRequiredInt(data, field, min, max) {
      return field in data &&
        data[field] is int &&
        data[field] >= min &&
        data[field] <= max;
    }

    function isRequiredBool(data, field) {
      return field in data && data[field] is bool;
    }

    function isOptionalBool(data, field) {
      return !(field in data) || data[field] is bool;
    }

    function isRequiredTimestamp(data, field) {
      return field in data && data[field] is timestamp;
    }

    function isOptionalTimestamp(data, field) {
      return !(field in data) || data[field] == null || data[field] is timestamp;
    }

    function isOptionalManualMode(data, field) {
      return !(field in data) ||
        data[field] == null ||
        (
          data[field] is map &&
          data[field].keys().hasOnly(['mode', 'setAt', 'expiresAt']) &&
          isRequiredString(data[field], 'mode', 32) &&
          data[field].mode in ['homework', 'bedtime', 'focus', 'free'] &&
          isOptionalTimestamp(data[field], 'setAt') &&
          isOptionalTimestamp(data[field], 'expiresAt')
        );
    }

    function isAllowedAgeBand(data, field) {
      return field in data &&
        data[field] is string &&
        data[field] in ['6-9', '10-13', '14-17'];
    }

    function hasRequiredAlertLocks(data) {
      return !('alertPreferences' in data) ||
        (
          data.alertPreferences is map &&
          (
            !('vpnDisabled' in data.alertPreferences) ||
            data.alertPreferences.vpnDisabled == true
          ) &&
          (
            !('uninstallAttempt' in data.alertPreferences) ||
            data.alertPreferences.uninstallAttempt == true
          ) &&
          (
            !('deviceOffline24h' in data.alertPreferences) ||
            data.alertPreferences.deviceOffline24h == true
          )
        );
    }

    // Parent profile document.
    match /parents/{parentId} {
      allow read: if isParent(parentId);

      allow create: if isParent(parentId) &&
        isRequiredString(request.resource.data, 'parentId', 128) &&
        request.resource.data.parentId == parentId &&
        (!('phone' in request.resource.data) ||
          request.resource.data.phone == null ||
          (request.resource.data.phone is string && request.resource.data.phone.size() <= 20)) &&
        (!('preferences' in request.resource.data) || request.resource.data.preferences is map) &&
        (!('subscription' in request.resource.data) || request.resource.data.subscription is map) &&
        isOptionalString(request.resource.data, 'fcmToken', 1024) &&
        isOptionalTimestamp(request.resource.data, 'createdAt') &&
        isOptionalTimestamp(request.resource.data, 'updatedAt') &&
        isOptionalTimestamp(request.resource.data, 'fcmTokenUpdatedAt') &&
        isOptionalTimestamp(request.resource.data, 'onboardingCompletedAt') &&
        hasRequiredAlertLocks(request.resource.data);

      allow update: if isParent(parentId) &&
        isRequiredString(request.resource.data, 'parentId', 128) &&
        request.resource.data.parentId == resource.data.parentId &&
        request.resource.data.parentId == parentId &&
        hasRequiredAlertLocks(request.resource.data);

      allow delete: if false;

      // Access requests live under each parent.
      match /access_requests/{requestId} {
        allow read: if isParent(parentId) ||
          (isAuthed() &&
            ('childId' in resource.data) &&
            resource.data.childId is string &&
            isChildDevice(resource.data.childId));

        allow create: if (isParent(parentId) ||
            (isAuthed() &&
              ('childId' in request.resource.data) &&
              request.resource.data.childId is string &&
              isChildDevice(request.resource.data.childId))) &&
          hasOnlyKeys(
            request.resource.data,
            [
              'childId',
              'parentId',
              'childNickname',
              'appOrSite',
              'durationMinutes',
              'durationLabel',
              'reason',
              'status',
              'parentReply',
              'requestedAt',
              'respondedAt',
              'expiresAt'
            ]
          ) &&
          isRequiredString(request.resource.data, 'childId', 128) &&
          isRequiredString(request.resource.data, 'parentId', 128) &&
          request.resource.data.parentId == parentId &&
          isRequiredString(request.resource.data, 'childNickname', 30) &&
          isRequiredString(request.resource.data, 'appOrSite', 100) &&
          isRequiredString(request.resource.data, 'durationLabel', 40) &&
          isOptionalInt(request.resource.data, 'durationMinutes', 1, 1440) &&
          isOptionalString(request.resource.data, 'reason', 200) &&
          request.resource.data.status == 'pending' &&
          isRequiredTimestamp(request.resource.data, 'requestedAt') &&
          (!('parentReply' in request.resource.data) || request.resource.data.parentReply == null) &&
          (!('respondedAt' in request.resource.data) || request.resource.data.respondedAt == null) &&
          (!('expiresAt' in request.resource.data) || request.resource.data.expiresAt == null);

        allow update: if isParent(parentId) &&
          (
            (
              resource.data.status == 'pending' &&
              request.resource.data.diff(resource.data).affectedKeys().hasOnly(
                ['status', 'parentReply', 'respondedAt', 'expiresAt']
              ) &&
              request.resource.data.status in ['approved', 'denied'] &&
              isOptionalString(request.resource.data, 'parentReply', 200) &&
              isRequiredTimestamp(request.resource.data, 'respondedAt') &&
              isOptionalTimestamp(request.resource.data, 'expiresAt')
            ) ||
            (
              resource.data.status == 'approved' &&
              request.resource.data.diff(resource.data).affectedKeys().hasOnly(
                ['status', 'parentReply', 'expiresAt', 'expiredAt', 'updatedAt']
              ) &&
              request.resource.data.status == 'expired' &&
              isOptionalString(request.resource.data, 'parentReply', 200) &&
              isRequiredTimestamp(request.resource.data, 'expiresAt') &&
              isRequiredTimestamp(request.resource.data, 'expiredAt') &&
              isRequiredTimestamp(request.resource.data, 'updatedAt')
            )
          );

        allow delete: if isParent(parentId);
      }
    }

    // Child profiles (top-level collection in v1 schema).
    match /children/{childId} {
      allow read: if (isAuthed() && resource.data.parentId == request.auth.uid) ||
        isChildDevice(childId);

      allow create: if isAuthed() &&
        hasOnlyKeys(
          request.resource.data,
          [
            'nickname',
            'ageBand',
            'deviceIds',
            'policy',
            'createdAt',
            'updatedAt',
            'parentId',
            'pausedUntil',
            'manualMode',
            'nextDnsProfileId',
            'deviceMetadata',
            'nextDnsControls'
          ]
        ) &&
        isRequiredString(request.resource.data, 'nickname', 30) &&
        isAllowedAgeBand(request.resource.data, 'ageBand') &&
        request.resource.data.deviceIds is list &&
        request.resource.data.policy is map &&
        isRequiredTimestamp(request.resource.data, 'createdAt') &&
        isRequiredTimestamp(request.resource.data, 'updatedAt') &&
        isRequiredString(request.resource.data, 'parentId', 128) &&
        request.resource.data.parentId == request.auth.uid &&
        isOptionalTimestamp(request.resource.data, 'pausedUntil') &&
        isOptionalManualMode(request.resource.data, 'manualMode') &&
        isOptionalString(request.resource.data, 'nextDnsProfileId', 32) &&
        (!('deviceMetadata' in request.resource.data) ||
          request.resource.data.deviceMetadata is map) &&
        (!('nextDnsControls' in request.resource.data) ||
          request.resource.data.nextDnsControls is map);

      allow update: if (
          isAuthed() &&
          resource.data.parentId == request.auth.uid &&
          request.resource.data.parentId == resource.data.parentId &&
          request.resource.data.diff(resource.data).affectedKeys().hasOnly(
            [
              'nickname',
              'ageBand',
              'deviceIds',
              'policy',
              'pausedUntil',
              'manualMode',
              'updatedAt',
              'nextDnsProfileId',
              'deviceMetadata',
              'nextDnsControls'
            ]
          ) &&
          isRequiredString(request.resource.data, 'nickname', 30) &&
          isAllowedAgeBand(request.resource.data, 'ageBand') &&
          request.resource.data.deviceIds is list &&
          request.resource.data.policy is map &&
          isRequiredTimestamp(request.resource.data, 'createdAt') &&
          isRequiredTimestamp(request.resource.data, 'updatedAt') &&
          isOptionalTimestamp(request.resource.data, 'pausedUntil') &&
          isOptionalManualMode(request.resource.data, 'manualMode') &&
          isOptionalString(request.resource.data, 'nextDnsProfileId', 32) &&
          (!('deviceMetadata' in request.resource.data) ||
            request.resource.data.deviceMetadata is map) &&
          (!('nextDnsControls' in request.resource.data) ||
            request.resource.data.nextDnsControls is map)
        ) || (
          isChildDevice(childId) &&
          request.resource.data.parentId == resource.data.parentId &&
          request.resource.data.diff(resource.data).affectedKeys().hasOnly(
            ['deviceIds', 'updatedAt']
          ) &&
          request.resource.data.deviceIds is list &&
          request.resource.data.deviceIds.hasAny([request.auth.uid]) &&
          isRequiredTimestamp(request.resource.data, 'updatedAt')
        );

      allow delete: if isAuthed() && resource.data.parentId == request.auth.uid;

      // Child device metadata records used for pairing and per-device push tokens.
      match /devices/{deviceId} {
        allow read: if isChildParent(childId) ||
          (isAuthed() && request.auth.uid == deviceId);

        allow create, update: if (isChildParent(childId) ||
            (isAuthed() && request.auth.uid == deviceId)) &&
          isRequiredString(request.resource.data, 'parentId', 128) &&
          request.resource.data.parentId ==
            get(/databases/$(database)/documents/children/$(childId)).data.parentId &&
          isOptionalString(request.resource.data, 'model', 120) &&
          isOptionalString(request.resource.data, 'osVersion', 120) &&
          isOptionalString(request.resource.data, 'fcmToken', 2048) &&
          isOptionalTimestamp(request.resource.data, 'pairedAt');

        allow delete: if false;
      }

      // Optional policy documents used by diagnostics/experiments.
      match /app_inventory/{inventoryId} {
        allow read: if isChildParent(childId) || isChildDevice(childId);

        allow create, update: if isChildDevice(childId) &&
          hasOnlyKeys(
            request.resource.data,
            [
              'version',
              'hash',
              'capturedAt',
              'deviceId',
              'apps',
              'inventoryStatus'
            ]
          ) &&
          isRequiredInt(request.resource.data, 'version', 0, 4102444800000) &&
          isRequiredString(request.resource.data, 'hash', 4096) &&
          isOptionalTimestamp(request.resource.data, 'capturedAt') &&
          isRequiredString(request.resource.data, 'deviceId', 128) &&
          ('apps' in request.resource.data) &&
          request.resource.data.apps is list &&
          (
            !('inventoryStatus' in request.resource.data) ||
            request.resource.data.inventoryStatus is map
          );

        allow delete: if false;
      }

      // Optional policy documents used by diagnostics/experiments.
      match /policy/{policyDocId} {
        allow read: if isChildParent(childId) || isChildDevice(childId);
        allow create, update, delete: if isChildParent(childId);
      }

      // Append-only policy events to preserve each distinct state change.
      match /policy_events/{eventId} {
        allow read: if isChildParent(childId) || isChildDevice(childId);

        allow create: if isChildParent(childId) &&
          hasOnlyKeys(
            request.resource.data,
            [
              'parentId',
              'childId',
              'blockedCategories',
              'blockedServices',
              'blockedDomains',
              'blockedPackages',
              'blockedDomainsResolved',
              'blockedPackagesResolved',
              'modeOverrides',
              'modeOverridesResolved',
              'policySchemaVersion',
              'manualMode',
              'pausedUntil',
              'sourceUpdatedAt',
              'eventEpochMs',
              'version',
              'createdAt'
            ]
          ) &&
          isRequiredString(request.resource.data, 'parentId', 128) &&
          request.resource.data.parentId ==
            get(/databases/$(database)/documents/children/$(childId)).data.parentId &&
          isRequiredString(request.resource.data, 'childId', 128) &&
          request.resource.data.childId == childId &&
          ('blockedCategories' in request.resource.data) &&
          request.resource.data.blockedCategories is list &&
          ('blockedServices' in request.resource.data) &&
          request.resource.data.blockedServices is list &&
          ('blockedDomains' in request.resource.data) &&
          request.resource.data.blockedDomains is list &&
          ('blockedPackages' in request.resource.data) &&
          request.resource.data.blockedPackages is list &&
          ('blockedDomainsResolved' in request.resource.data) &&
          request.resource.data.blockedDomainsResolved is list &&
          ('blockedPackagesResolved' in request.resource.data) &&
          request.resource.data.blockedPackagesResolved is list &&
          (!('modeOverrides' in request.resource.data) ||
            request.resource.data.modeOverrides is map) &&
          (!('modeOverridesResolved' in request.resource.data) ||
            request.resource.data.modeOverridesResolved is map) &&
          isRequiredInt(request.resource.data, 'policySchemaVersion', 1, 100) &&
          isOptionalManualMode(request.resource.data, 'manualMode') &&
          isOptionalTimestamp(request.resource.data, 'pausedUntil') &&
          isRequiredTimestamp(request.resource.data, 'sourceUpdatedAt') &&
          isRequiredInt(request.resource.data, 'eventEpochMs', 0, 4102444800000) &&
          isRequiredInt(request.resource.data, 'version', 0, 4102444800000) &&
          isRequiredTimestamp(request.resource.data, 'createdAt');

        allow update, delete: if false;
      }

      // Canonical derived policy snapshot used as child apply source-of-truth.
      match /effective_policy/{policyId} {
        allow read: if isChildParent(childId) || isChildDevice(childId);

        allow create, update: if isChildParent(childId) &&
          hasOnlyKeys(
            request.resource.data,
            [
              'parentId',
              'childId',
              'version',
              'blockedCategories',
              'blockedServices',
              'blockedDomains',
              'blockedPackages',
              'blockedDomainsResolved',
              'blockedPackagesResolved',
              'modeOverridesResolved',
              'policySchemaVersion',
              'manualMode',
              'pausedUntil',
              'sourceUpdatedAt',
              'updatedAt'
            ]
          ) &&
          isRequiredString(request.resource.data, 'parentId', 128) &&
          request.resource.data.parentId ==
            get(/databases/$(database)/documents/children/$(childId)).data.parentId &&
          isRequiredString(request.resource.data, 'childId', 128) &&
          request.resource.data.childId == childId &&
          isRequiredInt(request.resource.data, 'version', 0, 4102444800000) &&
          ('blockedCategories' in request.resource.data) &&
          request.resource.data.blockedCategories is list &&
          ('blockedServices' in request.resource.data) &&
          request.resource.data.blockedServices is list &&
          ('blockedDomains' in request.resource.data) &&
          request.resource.data.blockedDomains is list &&
          ('blockedPackages' in request.resource.data) &&
          request.resource.data.blockedPackages is list &&
          ('blockedDomainsResolved' in request.resource.data) &&
          request.resource.data.blockedDomainsResolved is list &&
          ('blockedPackagesResolved' in request.resource.data) &&
          request.resource.data.blockedPackagesResolved is list &&
          (!('modeOverridesResolved' in request.resource.data) ||
            request.resource.data.modeOverridesResolved is map) &&
          isRequiredInt(request.resource.data, 'policySchemaVersion', 1, 100) &&
          isOptionalManualMode(request.resource.data, 'manualMode') &&
          isOptionalTimestamp(request.resource.data, 'pausedUntil') &&
          isRequiredTimestamp(request.resource.data, 'sourceUpdatedAt') &&
          isOptionalTimestamp(request.resource.data, 'updatedAt');

        allow delete: if false;
      }

      // Child acknowledgement of policy application result per device.
      match /policy_apply_acks/{deviceId} {
        allow read: if isChildParent(childId) || isChildDevice(childId);

        allow create, update: if (
            isChildParent(childId) ||
            (
              isAuthed() &&
              isRegisteredChildDevice(childId, deviceId) &&
              isRequiredString(request.resource.data, 'parentId', 128) &&
              childParentMatches(childId, request.resource.data.parentId)
            )
          ) &&
          hasOnlyKeys(
            request.resource.data,
            [
              'parentId',
              'childId',
              'deviceId',
              'appliedVersion',
              'appliedAt',
              'vpnRunning',
              'appliedBlockedDomainsCount',
              'appliedBlockedPackagesCount',
              'applyLatencyMs',
              'usageAccessGranted',
              'ruleCounts',
              'applyStatus',
              'error',
              'updatedAt'
            ]
          ) &&
          isRequiredString(request.resource.data, 'childId', 128) &&
          request.resource.data.childId == childId &&
          isRequiredString(request.resource.data, 'deviceId', 128) &&
          request.resource.data.deviceId == deviceId &&
          isRequiredInt(request.resource.data, 'appliedVersion', 0, 4102444800000) &&
          isOptionalTimestamp(request.resource.data, 'appliedAt') &&
          isOptionalBool(request.resource.data, 'vpnRunning') &&
          isOptionalInt(request.resource.data, 'appliedBlockedDomainsCount', 0, 1000000) &&
          isOptionalInt(request.resource.data, 'appliedBlockedPackagesCount', 0, 1000000) &&
          isOptionalInt(request.resource.data, 'applyLatencyMs', 0, 86400000) &&
          isOptionalBool(request.resource.data, 'usageAccessGranted') &&
          (
            !('ruleCounts' in request.resource.data) ||
            (
              request.resource.data.ruleCounts is map &&
              request.resource.data.ruleCounts.keys().hasOnly([
                'categoriesExpected',
                'domainsExpected',
                'servicesExpected',
                'packagesExpected',
                'categoriesCached',
                'domainsCached'
              ]) &&
              isOptionalInt(request.resource.data.ruleCounts, 'categoriesExpected', 0, 1000000) &&
              isOptionalInt(request.resource.data.ruleCounts, 'domainsExpected', 0, 1000000) &&
              isOptionalInt(request.resource.data.ruleCounts, 'servicesExpected', 0, 1000000) &&
              isOptionalInt(request.resource.data.ruleCounts, 'packagesExpected', 0, 1000000) &&
              isOptionalInt(request.resource.data.ruleCounts, 'categoriesCached', 0, 1000000) &&
              isOptionalInt(request.resource.data.ruleCounts, 'domainsCached', 0, 1000000)
            )
          ) &&
          isRequiredString(request.resource.data, 'applyStatus', 32) &&
          request.resource.data.applyStatus in ['applied', 'failed', 'mismatch', 'error'] &&
          isOptionalString(request.resource.data, 'error', 500) &&
          isOptionalTimestamp(request.resource.data, 'updatedAt');

        allow delete: if false;
      }

      // Native/background VPN diagnostics written by child VPN service.
      match /vpn_diagnostics/{diagId} {
        allow read: if isChildParent(childId) || isChildDevice(childId);

        allow create, update: if isChildDevice(childId) &&
          hasOnlyKeys(
            request.resource.data,
            [
              'parentId',
              'childId',
              'deviceId',
              'vpnRunning',
              'privateDnsMode',
              'privateDnsActive',
              'protectionActive',
              'usageAccessGranted',
              'foregroundPackage',
              'browserForeground',
              'recentVpnDnsQueriesInWindow',
              'likelyDnsBypass',
              'bypassReasonCode',
              'lastBypassSignalAtEpochMs',
              'lastBypassSignalReasonCode',
              'lastBypassSignalForegroundPackage',
              'packetCounters',
              'lastDnsQuery',
              'lastBlockedDnsQuery',
              'updatedAt'
            ]
          ) &&
          isRequiredString(request.resource.data, 'parentId', 128) &&
          childParentMatches(childId, request.resource.data.parentId) &&
          isRequiredString(request.resource.data, 'childId', 128) &&
          request.resource.data.childId == childId &&
          isOptionalString(request.resource.data, 'deviceId', 128) &&
          isOptionalBool(request.resource.data, 'vpnRunning') &&
          isOptionalString(request.resource.data, 'privateDnsMode', 64) &&
          isOptionalBool(request.resource.data, 'privateDnsActive') &&
          isOptionalBool(request.resource.data, 'protectionActive') &&
          isOptionalBool(request.resource.data, 'usageAccessGranted') &&
          isOptionalString(request.resource.data, 'foregroundPackage', 256) &&
          isOptionalBool(request.resource.data, 'browserForeground') &&
          isOptionalInt(request.resource.data, 'recentVpnDnsQueriesInWindow', 0, 1000000) &&
          isOptionalBool(request.resource.data, 'likelyDnsBypass') &&
          isOptionalString(request.resource.data, 'bypassReasonCode', 120) &&
          isOptionalInt(request.resource.data, 'lastBypassSignalAtEpochMs', 0, 4102444800000) &&
          isOptionalString(request.resource.data, 'lastBypassSignalReasonCode', 120) &&
          isOptionalString(request.resource.data, 'lastBypassSignalForegroundPackage', 256) &&
          (!('packetCounters' in request.resource.data) ||
            request.resource.data.packetCounters is map) &&
          (!('lastDnsQuery' in request.resource.data) ||
            request.resource.data.lastDnsQuery == null ||
            request.resource.data.lastDnsQuery is map) &&
          (!('lastBlockedDnsQuery' in request.resource.data) ||
            request.resource.data.lastBlockedDnsQuery == null ||
            request.resource.data.lastBlockedDnsQuery is map) &&
          isOptionalTimestamp(request.resource.data, 'updatedAt');

        allow delete: if false;
      }

      // Parent-side debug traces for toggle/save -> effective policy investigations.
      match /parent_debug_events/{eventId} {
        allow read: if isChildParent(childId) || isChildDevice(childId);

        allow create: if isChildParent(childId) &&
          hasOnlyKeys(
            request.resource.data,
            [
              'parentId',
              'childId',
              'source',
              'screen',
              'eventType',
              'payload',
              'clientTime',
              'createdAt'
            ]
          ) &&
          isRequiredString(request.resource.data, 'parentId', 128) &&
          request.resource.data.parentId ==
            get(/databases/$(database)/documents/children/$(childId)).data.parentId &&
          isRequiredString(request.resource.data, 'childId', 128) &&
          request.resource.data.childId == childId &&
          isRequiredString(request.resource.data, 'source', 40) &&
          isRequiredString(request.resource.data, 'screen', 64) &&
          isRequiredString(request.resource.data, 'eventType', 80) &&
          (!('payload' in request.resource.data) || request.resource.data.payload is map) &&
          isOptionalTimestamp(request.resource.data, 'clientTime') &&
          isOptionalTimestamp(request.resource.data, 'createdAt');

        allow update, delete: if false;
      }

      // Child-uploaded usage snapshots rendered in parent reports.
      match /usage_reports/{reportId} {
        allow read: if isChildParent(childId) || isChildDevice(childId);

        allow create, update: if isChildDevice(childId) && (
          (
            reportId == 'latest' &&
            hasOnlyKeys(
              request.resource.data,
              [
                'totalScreenTimeMs',
                'averageDailyScreenTimeMs',
                'categorySlices',
                'dailyTrend',
                'topApps',
                'dayKey',
                'appUsageByPackage',
                'trendPoint',
                'uploadedAt',
                'deviceUploadedAtLocal'
              ]
            ) &&
            isRequiredInt(request.resource.data, 'totalScreenTimeMs', 0, 4102444800000) &&
            isRequiredInt(request.resource.data, 'averageDailyScreenTimeMs', 0, 4102444800000) &&
            ('categorySlices' in request.resource.data) &&
            request.resource.data.categorySlices is list &&
            ('dailyTrend' in request.resource.data) &&
            request.resource.data.dailyTrend is list &&
            ('topApps' in request.resource.data) &&
            request.resource.data.topApps is list &&
            (!('dayKey' in request.resource.data) || request.resource.data.dayKey is string) &&
            (!('appUsageByPackage' in request.resource.data) || request.resource.data.appUsageByPackage is map) &&
            (!('trendPoint' in request.resource.data) || request.resource.data.trendPoint is map) &&
            isOptionalTimestamp(request.resource.data, 'uploadedAt') &&
            isOptionalString(request.resource.data, 'deviceUploadedAtLocal', 80)
          ) ||
          (
            reportId.matches('^daily_[0-9]{4}-[0-9]{2}-[0-9]{2}$') &&
            hasOnlyKeys(
              request.resource.data,
              [
                'capturedAt',
                'dayKey',
                'totalScreenMinutes',
                'appUsageByPackage',
                'categoryTotals',
                'trendPoint',
                'uploadedAt',
                'deviceUploadedAtLocal'
              ]
            ) &&
            isOptionalTimestamp(request.resource.data, 'capturedAt') &&
            isRequiredString(request.resource.data, 'dayKey', 20) &&
            isRequiredInt(request.resource.data, 'totalScreenMinutes', 0, 2000000) &&
            ('appUsageByPackage' in request.resource.data) &&
            request.resource.data.appUsageByPackage is map &&
            ('categoryTotals' in request.resource.data) &&
            request.resource.data.categoryTotals is map &&
            ('trendPoint' in request.resource.data) &&
            request.resource.data.trendPoint is map &&
            isOptionalTimestamp(request.resource.data, 'uploadedAt') &&
            isOptionalString(request.resource.data, 'deviceUploadedAtLocal', 80)
          )
        );

        allow delete: if false;

        // Canonical nested daily path for v2 rollout:
        // children/{childId}/usage_reports/daily/days/{yyyy-MM-dd}
        match /days/{dayKey} {
          allow read: if reportId == 'daily' &&
            (isChildParent(childId) || isChildDevice(childId));

          allow create, update: if reportId == 'daily' &&
            isChildDevice(childId) &&
            dayKey.matches('^[0-9]{4}-[0-9]{2}-[0-9]{2}$') &&
            hasOnlyKeys(
              request.resource.data,
              [
                'capturedAt',
                'dayKey',
                'totalScreenMinutes',
                'appUsageByPackage',
                'categoryTotals',
                'trendPoint',
                'uploadedAt',
                'deviceUploadedAtLocal'
              ]
            ) &&
            isOptionalTimestamp(request.resource.data, 'capturedAt') &&
            isRequiredString(request.resource.data, 'dayKey', 20) &&
            request.resource.data.dayKey == dayKey &&
            isRequiredInt(request.resource.data, 'totalScreenMinutes', 0, 2000000) &&
            ('appUsageByPackage' in request.resource.data) &&
            request.resource.data.appUsageByPackage is map &&
            ('categoryTotals' in request.resource.data) &&
            request.resource.data.categoryTotals is map &&
            ('trendPoint' in request.resource.data) &&
            request.resource.data.trendPoint is map &&
            isOptionalTimestamp(request.resource.data, 'uploadedAt') &&
            isOptionalString(request.resource.data, 'deviceUploadedAtLocal', 80);

          allow delete: if false;
        }
      }
    }

    // Device heartbeat + command queue (root collection).
    match /devices/{deviceId} {
      allow read: if isAuthed() &&
        (
          request.auth.uid == deviceId ||
          (
            'parentId' in resource.data &&
            resource.data.parentId is string &&
            resource.data.parentId == request.auth.uid
          )
        );

      allow create, update: if isAuthed() &&
        isRequiredString(request.resource.data, 'deviceId', 128) &&
        request.resource.data.deviceId == deviceId &&
        isRequiredString(request.resource.data, 'parentId', 128) &&
        request.resource.data.parentId == request.auth.uid &&
        isRequiredString(request.resource.data, 'childId', 128) &&
        childParentMatches(
          request.resource.data.childId,
          request.resource.data.parentId
        ) &&
        isRegisteredChildDevice(request.resource.data.childId, deviceId) &&
        isOptionalTimestamp(request.resource.data, 'lastSeen') &&
        isOptionalInt(request.resource.data, 'lastSeenEpochMs', 0, 4102444800000) &&
        isOptionalBool(request.resource.data, 'vpnActive') &&
        isOptionalString(request.resource.data, 'appVersion', 120) &&
        isOptionalTimestamp(request.resource.data, 'updatedAt');

      allow delete: if false;

      // Parent-to-child remote command queue.
      match /pendingCommands/{commandId} {
        allow read: if isAuthed() &&
          (
            request.auth.uid == deviceId ||
            (
              'parentId' in resource.data &&
              resource.data.parentId is string &&
              resource.data.parentId == request.auth.uid
            )
          );

        allow create: if isAuthed() &&
          isRequiredString(request.resource.data, 'commandId', 128) &&
          request.resource.data.commandId == commandId &&
          isRequiredString(request.resource.data, 'parentId', 128) &&
          request.resource.data.parentId == request.auth.uid &&
          isRequiredString(request.resource.data, 'command', 64) &&
          request.resource.data.command in [
            'restartVpn',
            'clearPairingAndStopProtection'
          ] &&
          isRequiredString(request.resource.data, 'status', 32) &&
          request.resource.data.status == 'pending' &&
          isOptionalString(request.resource.data, 'childId', 128) &&
          isOptionalString(request.resource.data, 'reason', 120) &&
          isOptionalInt(request.resource.data, 'attempts', 0, 10) &&
          isOptionalTimestamp(request.resource.data, 'sentAt');

        allow update: if isAuthed() &&
          resource.data.parentId == request.auth.uid &&
          request.resource.data.parentId == resource.data.parentId &&
          request.resource.data.commandId == resource.data.commandId &&
          request.resource.data.command == resource.data.command &&
          request.resource.data.diff(resource.data).affectedKeys().hasOnly(
            ['status', 'attempts', 'executedAt', 'error', 'updatedAt']
          ) &&
          isRequiredString(request.resource.data, 'status', 32) &&
          request.resource.data.status in ['pending', 'executed', 'failed'] &&
          isOptionalInt(request.resource.data, 'attempts', 0, 10) &&
          isOptionalTimestamp(request.resource.data, 'executedAt') &&
          isOptionalString(request.resource.data, 'error', 200) &&
          isOptionalTimestamp(request.resource.data, 'updatedAt');

        allow delete: if false;
      }

      // Child-side bypass dedup metadata.
      match /lastAlerts/{eventType} {
        allow read: if parentOwnsRootDevice(deviceId);

        allow create, update: if parentOwnsRootDevice(deviceId) &&
          isOptionalTimestamp(request.resource.data, 'lastAlertAt') &&
          isOptionalInt(request.resource.data, 'lastAlertAtEpochMs', 0, 4102444800000) &&
          isOptionalString(request.resource.data, 'eventType', 64);

        allow delete: if false;
      }
    }

    // Bypass events logged from child devices and reviewed by parents.
    match /bypass_events/{deviceId} {
      allow read, write: if false;

      match /events/{eventId} {
        allow read: if isAuthed() &&
          (
            request.auth.uid == deviceId ||
            (
              'parentId' in resource.data &&
              resource.data.parentId is string &&
              resource.data.parentId == request.auth.uid
            )
          );

        allow create: if isAuthed() &&
          isRequiredString(request.resource.data, 'type', 64) &&
          isRequiredString(request.resource.data, 'deviceId', 128) &&
          request.resource.data.deviceId == deviceId &&
          isRequiredString(request.resource.data, 'childId', 128) &&
          isRequiredString(request.resource.data, 'parentId', 128) &&
          childParentMatches(
            request.resource.data.childId,
            request.resource.data.parentId
          ) &&
          (
            request.auth.uid == request.resource.data.parentId ||
            (
              request.auth.uid == deviceId &&
              isRegisteredChildDevice(request.resource.data.childId, deviceId)
            )
          ) &&
          isRequiredInt(request.resource.data, 'timestampEpochMs', 0, 4102444800000) &&
          isOptionalTimestamp(request.resource.data, 'timestamp') &&
          isRequiredBool(request.resource.data, 'read') &&
          isOptionalString(request.resource.data, 'childNickname', 60);

        allow update: if isAuthed() &&
          resource.data.parentId == request.auth.uid &&
          request.resource.data.diff(resource.data).affectedKeys().hasOnly(
            ['read', 'readAt']
          ) &&
          isRequiredBool(request.resource.data, 'read') &&
          request.resource.data.read == true &&
          isOptionalTimestamp(request.resource.data, 'readAt');

        allow delete: if false;
      }
    }

    // Parent-generated setup codes used to pair child devices.
    match /pairing_codes/{code} {
      allow read: if isAuthed();

      allow create: if isAuthed() &&
        isSixDigitCode(code) &&
        hasOnlyKeys(
          request.resource.data,
          ['code', 'childId', 'parentId', 'createdAt', 'expiresAt', 'used']
        ) &&
        request.resource.data.code == code &&
        isRequiredString(request.resource.data, 'childId', 128) &&
        isRequiredString(request.resource.data, 'parentId', 128) &&
        request.resource.data.parentId == request.auth.uid &&
        isRequiredTimestamp(request.resource.data, 'createdAt') &&
        isRequiredTimestamp(request.resource.data, 'expiresAt') &&
        isRequiredBool(request.resource.data, 'used') &&
        request.resource.data.used == false;

      allow update: if isAuthed() &&
        request.resource.data.diff(resource.data).affectedKeys().hasOnly(
          ['used', 'usedAt', 'usedByDeviceId']
        ) &&
        resource.data.used == false &&
        isRequiredBool(request.resource.data, 'used') &&
        request.resource.data.used == true &&
        isOptionalTimestamp(request.resource.data, 'usedAt') &&
        isOptionalString(request.resource.data, 'usedByDeviceId', 128);

      allow delete: if false;
    }

    // Queue used by Cloud Functions (client can write, cannot read).
    match /notification_queue/{docId} {
      allow read: if false;

      allow create: if isAuthed() &&
        hasOnlyKeys(
          request.resource.data,
          [
            'parentId',
            'childId',
            'deviceId',
            'title',
            'body',
            'route',
            'eventType',
            'processed',
            'sentAt'
          ]
        ) &&
        isRequiredString(request.resource.data, 'parentId', 128) &&
        (
          request.resource.data.parentId == request.auth.uid ||
          (
            isRequiredString(request.resource.data, 'childId', 128) &&
            isRequiredString(request.resource.data, 'deviceId', 128) &&
            request.resource.data.parentId == request.auth.uid &&
            childParentMatches(
              request.resource.data.childId,
              request.resource.data.parentId
            ) &&
            isRegisteredChildDevice(
              request.resource.data.childId,
              request.resource.data.deviceId
            )
          )
        ) &&
        isRequiredString(request.resource.data, 'title', 100) &&
        isRequiredString(request.resource.data, 'body', 300) &&
        isRequiredString(request.resource.data, 'route', 100) &&
        isOptionalString(request.resource.data, 'eventType', 64) &&
        isRequiredBool(request.resource.data, 'processed') &&
        request.resource.data.processed == false &&
        isRequiredTimestamp(request.resource.data, 'sentAt');

      allow update, delete: if false;
    }

    // Parent-submitted support tickets.
    match /supportTickets/{ticketId} {
      allow create: if isAuthed() &&
        hasOnlyKeys(
          request.resource.data,
          ['parentId', 'subject', 'message', 'childId', 'status', 'createdAt', 'updatedAt']
        ) &&
        isRequiredString(request.resource.data, 'parentId', 128) &&
        request.resource.data.parentId == request.auth.uid &&
        isRequiredString(request.resource.data, 'subject', 120) &&
        isRequiredString(request.resource.data, 'message', 2000) &&
        isOptionalString(request.resource.data, 'childId', 128) &&
        request.resource.data.status == 'open' &&
        isRequiredTimestamp(request.resource.data, 'createdAt') &&
        isRequiredTimestamp(request.resource.data, 'updatedAt');

      allow read: if isAuthed() && resource.data.parentId == request.auth.uid;
      allow update, delete: if false;
    }

    // Deny every non-whitelisted path.
    match /{document=**} {
      allow read, write: if false;
    }
  }
}
